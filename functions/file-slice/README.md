#  01. 大文件分片任务 & Web Worker

## 1.1 问题描述

- 在创建文件分片时会对每一个分片进行**唯一性标识**，我们采用 **MD5** 这种不可逆的哈希函数实现唯一标识。
- 使用 SparkMD5 库中的 **`spark.append(e.target.result)`** 函数**将当前分片的二进制数据追加到 MD5** 计算器中，再通过 **`end()`** 输出分片的唯一哈希值。
- 注意：**`append()`** 函数出现在 load 事件回调函数中，虽然事件回调函数是异步的，但是它会排队等候主线程，**最终在主线程中执行**。并且计算 MD5 哈希值的任务是一个 **CPU 密集型任务**，计算消耗非常大，会**使用主线程中的大量资源**。

## 1.2 并行计算 MD5 哈希值

- **开启 Web Worker 的线程数量**：线程数量最好和 CPU 的内核数量相同。可以使用 **`navigator.hardwareConcurrency`** 获取当前 CPU 的内核数量，否则默认采用 4 个线程。

```js
const THREAD_COUNT = navigator.hardwareConcurrency || 4 // 定义线程数量，与 CPU 内核数量一致
```

- **Web Worker 理解 1**：Web Worker 是**浏览器提供**的一个**线程接口**，它允许在主线程之外创建新的线程，并运行一段 JS 代码。每个 Worker 都在自己的线程中运行，与主线程是**并行**的。
- **Web Worker 理解 2**：Web Worker 并不是让 JavaScript 本身支持多线程，而是浏览器环境提供了额外的线程能力。即 JavaScript 是单线程语言，但**浏览器运行环境是多线程**的。
- **DedicatedWorker（专用线程）**：简称 Worker，其线程**只能与一个页面渲染进程**进行绑定和通信，**不能多标签页共享数据**。
- **SharedWorker（共享线程）**：可以在**多个浏览器标签页**中访问到同一个 Worker 实例，实现多标签页共享数据，共享 webSocket 连接等。
- **线程通信**：它与主线程之间通过**消息传递(postMessage)**进行**异步通信**，并且**不能直接访问主线程的变量或 DOM。**在数据传递的时候， Worker 是使用**拷贝**的方式。
- **Web Worker 并发与异步编程并发：**JS 异步编程中的并发（如 Promise.all）运行时**只有一个函数调用栈**，通过事件循环实现不同任务的上下文切换，但回调函数代码逻辑依然**由 JS 串行运行**。而 Web Worker 并发的特点在于有多个函数调用栈， 每个函数调用栈可以**独立运行 一个任务**，互不干扰。
- **使用场景**：将 **CPU 密集型任务**放在 woker 线程中进行，避免页面卡顿。如果直接在主线程里运行 CPU 密集型，则页面会**卡顿几秒钟**，用户体验会很差。使用 Web Worker，将计算任务被放到**后台线程中执行**，主线程可以继续响应用户操作，比如滑动、点击等。

| **Worker 特点**  | **理解**                                                     |
| ---------------- | ------------------------------------------------------------ |
| **文件限制**     | Worker 线程无法读取本地文件 `file://`，会拒绝使用 file 协议来创建 Worker 实例，它所**加载的脚本必须来自网络**。 |
| **同源限制**     | 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 |
| **DOM 操作限制** | Worker 线程所在的全局对象与主线程不一样。它无法读取主线程所在网页的 DOM 对象，也无法使用 document、window、parent 这些对象。 |

